.\" generated with Ronn/v0.7.3
.\" http://github.com/rtomayko/ronn/tree/0.7.3
.
.TH "JUGGLINGDB\-MODEL" "3" "August 2013" "1602 Software" "JugglingDB"
.
.SH "NAME"
\fBjugglingdb\-model\fR \- Model methods, features and internals
.
.SH "DESCRIPTION"
This section describes common methods of models managed by jugglingdb and explains some model internals, such as data representation, setters, getters and virtual attributes\.
.
.SH "DB WRITE METHODS"
Database write methods performs hooks and validations\. See jugglingdb\-hooks(3) and jugglingdb\-validations(3) to learn how hooks and validations works\.
.
.SS "Model\.create([data[, callback]]);"
Create instance of Model with given data and save to database\. Invoke callback when ready\. Callback accepts two arguments: error and model instance\.
.
.IP "" 4
.
.nf

User\.create({name: \'Jared Hanson\'}, function(err, user) {
    console\.log(user instanceof User);
});
.
.fi
.
.IP "" 0
.
.P
When called with array of objects as first argument \fBModel\.create\fR creates bunch of records\. Both \fBerr\fR and \fBmodel instance\fR arguments passed to callback will be arrays then\. When no errors happened \fBerr\fR argument will be null\.
.
.P
The value returned from \fBModel\.create\fR depends on second argument too\. In case of Array it will return an array of instances, otherwise single instance\. But be away, this instance(s) aren\'t save to database yet and you have to wait until callback called to be able to do id\-sensitive stuff\.
.
.SS "Model\.prototype\.save([options[, callback]]);"
Save instance to database, options is an object {validate: true, throws: false}, it allows to turn off validation (turned on by default) and throw error on validation error (doesn\'t throws by default)\.
.
.IP "" 4
.
.nf

user\.email = \'incorrect email\';
user\.save({throws: true}, callback); // will throw ValidationError
user\.save({validate: false}, callback); // will save incorrect data
user\.save(function(err, user) {
    console\.log(err); // ValidationError
    console\.log(user\.errors); // some errors
});
.
.fi
.
.IP "" 0
.
.SS "Model\.prototype\.updateAttributes(data[, callback]);"
Save specified attributes database\. Invoke callback when ready\. Callback accepts two arguments: error and model instance\.
.
.IP "" 4
.
.nf

user\.updateAttributes({
    email: \'new\-email@example\.com\',
    name: \'New Name\'
}, callback);
.
.fi
.
.IP "" 0
.
.SS "Model\.prototype\.updateAttribute(key, value[, callback]);"
Shortcut for updateAttributes, but for one field, works in the save way as updateAttributes\.
.
.IP "" 4
.
.nf

user\.updateAttribute(\'email\', \'new\-email@example\.com\', callback);
.
.fi
.
.IP "" 0
.
.SS "Model\.upsert(data, callback)"
Update when record with id=data\.id found, insert otherwise\. Be aware: no setters, validations or hooks applied when use upsert\. This is seed\-friendly method\.
.
.SS "Model\.prototype\.destroy([callback]);"
Delete database record\. Invoke callback when ready\. Callback accepts two arguments: error and model instance\.
.
.IP "" 4
.
.nf

model\.destroy(function(err) {
    // model instance destroyed
});
.
.fi
.
.IP "" 0
.
.SS "Model\.destroyAll(callback)"
Delete all Model instances from database\. Be aware: \fBdestroyAll\fR method doesn\'t perform destroy hooks\.
.
.SS "Model\.iterate(options, iterator, callback)"
Iterate through dataset and perform async method iterator\. This method designed to work with large datasets loading data by batches\. First argument (options) is optional and have same signature as for Model\.all, it has additional member \fBbatchSize\fR which allows to specify size of batch loaded into memory from the database\.
.
.P
Iterator argument is a function that accepts three arguments: item, callback and index in collection\.
.
.IP "" 4
.
.nf

Model\.iterate({batchSize: 100}, function(obj, next, i) {
    doSomethingAsync(obj, next);
}, function(err) {
    // all done
});
.
.fi
.
.IP "" 0
.
.SH "DB READ METHODS"
.
.SS "Model\.find(id, callback);"
Find instance by id\. Invoke callback when ready\. Callback accepts two arguments: error and model instance\.
.
.SS "Model\.all([params, ]callback);"
Find all instances of Model, matched by query\. Fields used for filter and sort should be declared with \fB{index: true}\fR in model definition\.
.
.IP "\(bu" 4
\fBparam\fR:
.
.IP "\(bu" 4
where: Object \fB{ key: val, key2: {gt: \'val2\'}}\fR
.
.IP "\(bu" 4
include: String, Object or Array\. See AbstractClass\.include documentation\.
.
.IP "\(bu" 4
order: String
.
.IP "\(bu" 4
limit: Number
.
.IP "\(bu" 4
skip: Number
.
.IP "" 0

.
.IP "\(bu" 4
\fBcallback\fR: Accepts two arguments:
.
.IP "\(bu" 4
err (null or Error)
.
.IP "\(bu" 4
Array of instances
.
.IP "" 0

.
.IP "" 0
.
.SS "Model\.count([query, ]callback);"
Query count of instances stored in database\. Optional \fBquery\fR param allows to count filtered set of records\. Callback called with error and count arguments\.
.
.IP "" 4
.
.nf

User\.count({approved: true}, function(err, count) {
    console\.log(count); // count of approved users stored in database
});
.
.fi
.
.IP "" 0
.
.SH "RELATIONS"
.
.SS "hasMany"
Define all necessary stuff for "one to many" relation:
.
.IP "\(bu" 4
foreign key in "many" model
.
.IP "\(bu" 4
named scope in "one" model
.
.IP "" 0
.
.P
Example:
.
.IP "" 4
.
.nf

var Book = db\.define(\'Book\');
var Chapter = db\.define(\'Chapters\');

// syntax 1 (old):
Book\.hasMany(Chapter);
// syntax 2 (new):
Book\.hasMany(\'chapters\');
.
.fi
.
.IP "" 0
.
.P
Syntax 1 and 2 does same things in different ways: adds \fBchapters\fR method to \fBBook\.prototype\fR and add \fBbookId\fR property to \fBChapter\fR model\. Foreign key name (\fBbookId\fR) could be specified manually using second param:
.
.IP "" 4
.
.nf

Book\.hasMany(\'chapters\', {foreignKey: `chapter_id`});
.
.fi
.
.IP "" 0
.
.P
When using syntax 2 jugglingdb looking for model with singularized name:
.
.IP "" 4
.
.nf

\'chapters\' => \'chapter\' => \'Chapter\'
.
.fi
.
.IP "" 0
.
.P
But it\'s possible to specify model manually using second param:
.
.IP "" 4
.
.nf

Book\.hasMany(\'stories\', {model: Chapter});
.
.fi
.
.IP "" 0
.
.P
Syntax 1 allows to override scope name using \fBas\fR property of second param:
.
.IP "" 4
.
.nf

Book\.hasMany(Chapter, {as: \'stories\'});
.
.fi
.
.IP "" 0
.
.P
\fBScope methods\fR created on BaseClass by hasMany allows to build, create and query instances of other class\. For example:
.
.IP "" 4
.
.nf

Book\.create(function(err, book) {
    // using \'chapters\' scope for build:
    var c = book\.chapters\.build({name: \'Chapter 1\'});
    // same as:
    c = new Chapter({name: \'Chapter 1\', bookId: book\.id});
    // using \'chapters\' scope for create:
    book\.chapters\.create();
    // same as:
    Chapter\.create({bookId: book\.id});

    // using scope for querying:
    book\.chapters(function() {/* all chapters with bookId = book\.id */ });
    book\.chapters({where: {name: \'test\'}, function(err, chapters) {
        // all chapters with bookId = book\.id and name = \'test\'
    });
});
.
.fi
.
.IP "" 0
.
.SS "belongsTo"
TODO: document
.
.SS "hasAndBelongsToMany"
TODO: document
.
.SH "SEE ALSO"
jugglingdb\-schema(3) jugglingdb\-validations(3) jugglingdb\-hooks(3) jugglingdb\-adapter(3)
